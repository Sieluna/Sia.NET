namespace Sia.CodeGenerators;

using System.Reflection;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Globalization;
using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis.CSharp;

internal static class Common
{
    public static readonly AssemblyName AssemblyName = typeof(Common).Assembly.GetName();
    public static readonly string GeneratedCodeAttribute =
        $@"global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{AssemblyName.Name}"", ""{AssemblyName.Version}"")";

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool FindParentNode<TNode>(
        SyntaxNode node, [MaybeNullWhen(false)] out TNode result)
        where TNode : SyntaxNode
    {
        SyntaxNode? currNode = node;
        while (currNode != null) {
            var parent = currNode.Parent;
            if (parent is TNode casted) {
                result = casted;
                return true;
            }
            currNode = parent;
        }
        result = default;
        return false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ImmutableArray<TypeDeclarationSyntax> GetParentTypes(SyntaxNode node)
    {
        var builder = ImmutableArray.CreateBuilder<TypeDeclarationSyntax>();
        var parent = node.Parent;

        while (parent != null) {
            if (parent is TypeDeclarationSyntax typeDecl) {
                builder.Add(typeDecl);
            }
            parent = parent.Parent;
        }

        return builder.ToImmutable();
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string GetFullType(SemanticModel model, SyntaxNode typeNode, CancellationToken token)
        => model.GetTypeInfo(typeNode, token).Type!.ToDisplayString(SymbolDisplayFormats.TypeParameter);
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static string GetVariableType(SemanticModel model, VariableDeclaratorSyntax syntax, CancellationToken token) {
        var parentDecl = (VariableDeclarationSyntax)syntax.Parent!;
        return GetFullType(model, parentDecl.Type, token);
    }

    public static IndentedTextWriter CreateSource(out StringBuilder builder)
    {
        builder = new StringBuilder();
        var writer = new StringWriter(builder, CultureInfo.InvariantCulture);
        var source = new IndentedTextWriter(writer, "    ");

        source.WriteLine("// <auto-generated/>");
        source.WriteLine("#nullable enable");
        source.WriteLine();

        return source;
    }

    private class EmptyDisposable : IDisposable
    {
        public static readonly EmptyDisposable Instance = new();

        public void Dispose() {}
    }

    private class EnclosingDisposable : IDisposable
    {
        private readonly IndentedTextWriter _source;
        private readonly int _count;

        public EnclosingDisposable(IndentedTextWriter source, int count)
        {
            _source = source;
            _count = count;
        }

        public void Dispose()
        {
            for (int i = 0; i < _count; ++i) {
                _source.Indent--;
                _source.WriteLine("}");
            }
        }
    }

    public static IDisposable GenerateInNamespace(IndentedTextWriter source, INamespaceSymbol ns)
    {
        var hasNamespace = !ns.IsGlobalNamespace;
        if (hasNamespace) {
            source.Write("namespace ");
            source.WriteLine(ns.ToDisplayString());
            source.WriteLine("{");
            source.Indent++;
            return new EnclosingDisposable(source, 1);
        }
        else {
            return EmptyDisposable.Instance;
        }
    }

    public static IDisposable GenerateInPartialTypes(IndentedTextWriter source, IEnumerable<TypeDeclarationSyntax> typeDecls)
    {
        int indent = 0;
        foreach (var typeDecl in typeDecls) {
            if (typeDecl.Modifiers.Any(SyntaxKind.StaticKeyword)) {
                source.Write("static ");
            }
            switch (typeDecl.Kind()) {
            case SyntaxKind.ClassDeclaration:
                source.Write("partial class ");
                break;
            case SyntaxKind.StructDeclaration:
                source.Write("partial struct ");
                break;
            case SyntaxKind.RecordDeclaration:
                source.Write("partial record ");
                break;
            case SyntaxKind.RecordStructDeclaration:
                source.Write("partial record struct ");
                break;
            default:
                throw new InvalidDataException("Invalid containing type");
            }
            
            WriteType(source, typeDecl);

            source.WriteLine();
            source.WriteLine("{");
            source.Indent++;
            indent++;
        }
        return indent != 0 ? new EnclosingDisposable(source, indent) : EmptyDisposable.Instance;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void WriteType(IndentedTextWriter source, TypeDeclarationSyntax typeDecl)
    {
        source.Write(typeDecl.Identifier.ToString());
        WriteTypeParameters(source, typeDecl);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void WriteTypeParameters(IndentedTextWriter source, TypeDeclarationSyntax typeDecl)
    {
        var typeParams = typeDecl.TypeParameterList;
        if (typeParams != null) {
            WriteTypeParameters(source, typeParams);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void WriteTypeParameters(IndentedTextWriter source, TypeParameterListSyntax typeParams)
    {
        source.Write('<');
        var paramsList = typeParams.Parameters;
        var lastIndex = paramsList.Count - 1;
        for (int i = 0; i != paramsList.Count; ++i) {
            source.Write(paramsList[i].Identifier.ToString());
            if (i != lastIndex) {
                source.Write(", ");
            }
        }
        source.Write('>');
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable<T> RepeatInfinitely<T>(T value)
    {
        while (true) {
            yield return value;
        }
    }
}